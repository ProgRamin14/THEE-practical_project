---
title: "Evolutionary rescue in flooding events"
author: "Ramin Dürst & Matthias Schönholzer"
date: "16.10.2024"
output:
  html_document:
    df_print: paged
co-author: "Base code by Claudia Bank"
---

## List of variables and parameters

-   $N_a$ current size of the wild-type (a) population (changes over time)
-   $N_A$ current size of the mutant (A) population (changes over time)
-   `N_init_a` initial population size of wild-type population (should be a positive integer)
-   `N_init_A` initial population size of the mutant population (~~should be a non-negative integer~~ –\> will be 0 at start)
-   `decay_rate` detrimental effect of the environment on the wild type (i.e., the wild-type population decays at this rate; should be \>0 to induce potential extinction)
-   `sel_coeff` ~~selective advantage of the mutant over the wild type (should be \>decay_rate to allow for evolutionary rescue)~~ –\> selection coefficient of wild type declines during the event, while the selection coefficient of the mutant increases during an event.
-   `mut_rate` mutation rate from the wild type to the mutant genotype (should be \>0 and small)
-   `t_max` number of generations after which to stop the simulation (should be an integer \>0; this is not a model parameter but a setting for the simulations). In the code presented here, the simulation stops automatically if the population goes extinct, or if it recovers and exceeds 1.5 times the original total population size, so `t_max` can be set to a large value without creating extremely long simulation times.
-   `duration of events` the timespan of generations the event occurs. Depends on the decay rate of the wild type and will be over 1.
-   `frequency of events` at which frequency the events occur over time
-   `strength of events` how strong the events affect the population. Is a combination of decay / growth rate and selection coefficient.

## Scenario

A hypothetical population of plants in a water meadow by a river with two genotypes: one which does bad during flooding (wild type) and one which does good during flooding (mutant). The frequency of being flooded increases due to climate change and depending on frequency, either the wild type persists, the mutant takes over, or both genotypes and therefor the population go extinct.

## Simulate one generation of population size change

We want to observe the numbers of wild-type and mutant individuals over time. As first step, we simulate one generation of the population. At time $t$, the population has $N_a$ wild-type individuals and $N_A$ mutant individuals. First, these reproduce. This is modeled by drawing a Poisson random variable according to the expected absolute number $N_a \cdot (1-r)$ of wild-type individuals, where $r$ is the decay rate of the wild type, and $N_A \cdot (1-r+s)$ of mutant individuals, where $s$ is the selective advantage of the mutant over the wild time. Then mutation from $a$ to $A$ occurs as a Poisson random variable according to the given mutation rate. This defines the composition of the population at time $t+1$.

```{r}
#Original

simulate_one_gen <- function(N_a, N_A, decay_rate, sel_coeff, mut_rate) {
  # draw offspring according to Poisson distribution
  offsp_a <- rpois(1, N_a * (1-decay_rate))
  offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
  # draw new mutants according to Poisson distribution
  mut_a_to_A <- rpois(1, offsp_a * mut_rate)
  
  # determine new population sizes of wild type and mutant
  N_a_new <- max(offsp_a - mut_a_to_A, 0)
  N_A_new <-  offsp_A + mut_a_to_A
  
  return(c(N_a_new, N_A_new))
}
# Test the function
print(simulate_one_gen(100,0,0.1,0.2,0.0))
```

## Simulate a population trajectory

We can now track the dynamics of the population from one generation to another, but this is not enough. We want to follow the population from time 0 until it either is rescued or goes extinct. This is what the following function does.

```{r}
#Original

simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
  # Create the vector in which to save the results
  pop_vector <- c(N_init_a, N_init_A)
  # initiate the variables
  pop_new <- c(N_init_a, N_init_A)
  
  # run the simulation until generation t_max
  for (i in 1:t_max+1) {
    # redefine the current population one generation later
    pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
    # condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
    if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
  }
  
  # define the row and column names of the output vector
  rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
  colnames(pop_vector) <- c("a","A")
  # return the result
  return(pop_vector)	
}


# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data, without mut_rate & sel_coeff and a higher decay_rate
output <- simulate_pop(1000,0,0.1,0.2,0.001,max_gen)
# show the last few lines of the data table
print(output)
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range 
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
```

## "Forever-Event" - Find the time to extinction

Simulating only the WT under "Flooding"-Event circumstances (higher decay rate). Without Mutant, to find the time it takes for the WT to go extinct.
This code is copied from the code block above (from Line 57).

```{r}
simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
  # Create the vector in which to save the results
  pop_vector <- c(N_init_a, N_init_A)
  # initiate the variables
  pop_new <- c(N_init_a, N_init_A)
  
  # run the simulation until generation t_max
  for (i in 1:t_max+1) {
    # redefine the current population one generation later
    pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
    # condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
    if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
  }
  
  # define the row and column names of the output vector
  rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
  colnames(pop_vector) <- c("a","A")
  # return the result
  return(pop_vector)	
}


# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.35,0,0,max_gen) #mut rate and initial mutation pop are 0 to time the decay of WT population
# show the last few lines of the data table
print(output)
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range 
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
```

## A small analysis

As you can see if you simulate and plot the output several times, there is a lot of stochasticity/variation in the outcome. Therefore, to get interpretable results, we have to run the simulation many times and summarize the outcome depending on the question of our study. Here I am showing an example in which we record the time and the value of the lowest population size (or the time of extinction, if the population size eventually goes to 0). Usually, we want to study this for a range of model parameters; here I am varying the decay rate and the selection coefficient. Other (maybe more interesting) features to study would be the following:

-   rescue probability dependent on initial frequency and selection coefficient
-   time at which the rescue mutation occurs first if it rescues, vs. if it doesn't rescue, dependent on initial population size and mutation rate
-   time until the population has recovered in case it becomes rescued, dependent on mutation rate and selection coefficient
-   ...

```{r}
#Original

# set some parameters to fixed values
init_a <- 100
init_A <- 0
m_rate <- 0.001
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 100

# set parameters to vary
s_values <- c(0.2,0.3,0.4)
r_values <- c(0.05,0.1,0.15)

# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
  # loop over selection coefficients
  for(sval in s_values){
    # different way of running many simulations: make replicates using "repeat" function with a counter i
    # reset counter
    i<-1
    repeat {
      # increase counter by one
      i<-i+1
      # run the simulation once
      one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
      # determine total population sizes
      total_size <- one_run[,1]+one_run[,2]
      # determine minimum population size
      min_size <- min(total_size)
      # determine (first) generation at which this population size occurred
      min_gen <- as.numeric(which(total_size==min_size)[1])
      # enter the data into the table
      data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
      # stop the repeated computation after no_replicates times
      if(i>no_replicates) break
    }
  }
}
# define column names of data table
colnames(data_table) <- c("r","s","min_gen","no_min")
# show the first lines of the output
print(head(data_table))
```

## Replicating "Forever-Event" for several generations

Finding the average time for the WT to go extinct in an event.
The code simulates several generations of events and returns the average of how fast the WT population goes extinct, when we have a higher decay rate (r_values in line 225)
This code is copied from the code block above (from Line 159).

```{r}
# set some parameters to fixed values, m_rate is 0
init_a <- 100
init_A <- 0
m_rate <- 0
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 750

# set parameters to vary, r_values (decay) is fixed
s_values <- c(0.2,0.3,0.4)
r_values <- 0.01

# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
  # loop over selection coefficients
  for(sval in s_values){
    # different way of running many simulations: make replicates using "repeat" function with a counter i
    # reset counter
    i<-1
    repeat {
      # increase counter by one
      i<-i+1
      # run the simulation once
      one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
      # determine total population sizes
      total_size <- one_run[,1]+one_run[,2]
      # determine minimum population size
      min_size <- min(total_size)
      # determine (first) generation at which this population size occurred
      min_gen <- as.numeric(which(total_size==0))
      # enter the data into the table
      data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
      # stop the repeated computation after no_replicates times
      if(i>no_replicates) break
    }
  }
}
# define column names of data table
colnames(data_table) <- c("r","s","min_gen","no_min")
# show the first lines of the output
print(head(data_table))
#mean of generations after which the WT population goes extinct
mean.extWT <- mean(min_gen)

print(mean.extWT)
```

## Implement several Events

The goal: Find a range of interesting frequencies of events at which the WT population starts struggling or goes extinct.
This code simulate a generation after another, depending on in which generation it starts. A list contains several starts of Events which then determines the decay rate at which the generation is simulated. This code only works for one generation and ignores, that an events lasts longer than one generation.
The code was written from scratch and copied from the first code block (about the simulate_one_gen)

```{r}
decay_rate = c(0.35, 1.1) #decay rate in presence and absence of event --> strength of event
freq_event = 10 #every 10 generations an event happens
dur_event = 2 #event has a duration of 2 generations
t_max = 100
gen = 0
start_event = list()

while (gen < t_max){
  start_event <- append(start_event, gen)
  gen = gen + dur_event + freq_event
}
#print(start_event)
#start_event[1]
#start_event[2]
#start_event[3]
#start_event[4]
#start_event[5]
#start_event <- c(start_event,start_event+1,start_event+2)
simulate_one_gen_2 <- function(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen) {
  if(gen %in% start_event) {
    decay_rate = 0.35
    growth_rate = 0
  }
  else{
      decay_rate = 0
      growth_rate = 1.1
  }
  offsp_a <- rpois(1, N_a * (1-decay_rate))
  offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
  # draw new mutants according to Poisson distribution
  mut_a_to_A <- rpois(1, offsp_a * mut_rate)
  
  # determine new population sizes of wild type and mutant
  N_a_new <- max(offsp_a - mut_a_to_A, 0)
  N_A_new <-  offsp_A + mut_a_to_A
  
  return(c(N_a_new, N_A_new))
}

print(simulate_one_gen_2(100, 0, 0, 1.2, 0, 0, 3))


#This was just to test, did not work
#for (i in 1:t_max+1) {
 # new_pop <- simulate_one_gen_2(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen)
  #vector_pop <- rbind(vector_pop, new_pop)
  #if(new)


```

## After discussion with Loic - see photo on repository

The timeline is separated into phases, which indicate where there is an event or not. for example; odd phase-number indicate no event and even phase-number indicates an event. The following code should simulate the population according to the phase and check if the phase number corresponds to an event or not.
The code was produced after a discussion with Loic.

```{r}
t_pause = 10 #t_switch
t_event = 2
t_switch = t_pause
ph = 1
sel_coeff = 0.0

replicates <- 100

flooding_table <- c()


for (i in 1:t_max+1){
  if(ph %%2 == 0){
    decay_rate = 0.3
  }else{
    decay_rate = 0
  }

  if (i >= t_switch) {
    if(ph %% 2 == 0) {
      t_switch = t_switch + t_event
      ph = ph + 1
    }else{
      t_switch = t_switch + t_pause
      ph = ph + 1
    }
  }
}

colnames(flooding_table) <- c("N_a_new", "N_A_new")

#print(simulate_one_gen_3(100, 0, 0, 1.2, 0, 0, 3))
print(head(flooding_table))


```


## Simulating a whole population

Generate a population with the influence of events. 
Here we are trying to determine the right parameters to then fix and later only vary with the frequency (t_pause).

```{r}
t_pause = 10 #t_switch, time between events
t_event = 5 #duration of event
t_switch = t_pause
sel_coeff = 0.0

#flooding_table <- c()

simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
  # Create the vector in which to save the results
  pop_vector <- c(N_init_a, N_init_A)
  # initiate the variables
  pop_new <- c(N_init_a, N_init_A)
  
  ph = 0 #phase in the beginning of the simulation

  
  # run the simulation until generation t_max
  for (i in 1:t_max+1) {
    if(ph %%2 == 0){ #checking in which phase the simulation is, still needs fine-tuning
    decay_rate = -0.03 #no event - parameters
    sel_coeff = -0.025
  }else{
    decay_rate = 0.03 #event - parameters
    sel_coeff = 0.01
  }

  if (i >= t_switch) { #changing the phase number, if the simulation is at the end of the phase
    if(ph %% 2 == 0) {
      t_switch = t_switch + t_event
      ph = ph + 1
    }else{
      t_switch = t_switch + t_pause
      ph = ph + 1
    }
  }
    
    # redefine the current population one generation later
    pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
    # condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
    if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
  }
  
  # define the row and column names of the output vector
  rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
  colnames(pop_vector) <- c("WT","Mut")
  # return the result
  return(pop_vector)	
}

# Test the function and plot the result
# set t_max to a value to be used throughout
max_gen <- 50
# create your simulation data
output <- simulate_pop(1000,0,0.35,0.01,0.005,max_gen) 
# show the last few lines of the data table
print(output)
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range 
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")

```


## Test area:
Code from the "Test Area" (just some coding bits that were used to try to figure stuff out, nothing really worked) and the part about reproducability were moved, for the sake of tidiness and better overview, to a different document (THEE-Project-Appendix).
