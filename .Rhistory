#start_event[2]
#start_event[3]
#start_event[4]
#start_event[5]
#start_event <- c(start_event,start_event+1,start_event+2)
simulate_one_gen_2 <- function(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen) {
if(gen %in% start_event) {
decay_rate = 0.35
growth_rate = 0
}
else{
decay_rate = 0
growth_rate = 1.1
}
offsp_a <- rpois(1, N_a * (1-decay_rate))
offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
# draw new mutants according to Poisson distribution
mut_a_to_A <- rpois(1, offsp_a * mut_rate)
# determine new population sizes of wild type and mutant
N_a_new <- max(offsp_a - mut_a_to_A, 0)
N_A_new <-  offsp_A + mut_a_to_A
return(c(N_a_new, N_A_new))
}
print(simulate_one_gen_2(100, 0, 0, 1.2, 0, 0, 3))
#for (i in 1:t_max+1) {
# new_pop <- simulate_one_gen_2(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen)
#vector_pop <- rbind(vector_pop, new_pop)
#if(new)
simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_init_a, N_init_A)
# initiate the variables
pop_new <- c(N_init_a, N_init_A)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.35,0,0,max_gen)
# set some parameters to fixed values, m_rate is 0
init_a <- 100
init_A <- 0
m_rate <- 0
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 750
# set parameters to vary, r_values (decay) is fixed
s_values <- c(0.2,0.3,0.4)
r_values <- 0.35
# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
# loop over selection coefficients
for(sval in s_values){
# different way of running many simulations: make replicates using "repeat" function with a counter i
# reset counter
i<-1
repeat {
# increase counter by one
i<-i+1
# run the simulation once
one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
# determine total population sizes
total_size <- one_run[,1]+one_run[,2]
# determine minimum population size
min_size <- min(total_size)
# determine (first) generation at which this population size occurred
min_gen <- as.numeric(which(total_size==0))
# enter the data into the table
data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
# stop the repeated computation after no_replicates times
if(i>no_replicates) break
}
}
}
# set some parameters to fixed values, m_rate is 0
init_a <- 100
init_A <- 0
m_rate <- 0
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 750
# set parameters to vary, r_values (decay) is fixed
s_values <- c(0.2,0.3,0.4)
r_values <- 0.35
# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
# loop over selection coefficients
for(sval in s_values){
# different way of running many simulations: make replicates using "repeat" function with a counter i
# reset counter
i<-1
repeat {
# increase counter by one
i<-i+1
# run the simulation once
one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
# determine total population sizes
total_size <- one_run[,1]+one_run[,2]
# determine minimum population size
min_size <- min(total_size)
# determine (first) generation at which this population size occurred
min_gen <- as.numeric(which(total_size==0))
# enter the data into the table
data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
# stop the repeated computation after no_replicates times
if(i>no_replicates) break
}
}
}
simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_init_a, N_init_A)
# initiate the variables
pop_new <- c(N_init_a, N_init_A)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.35,0,0,max_gen)
simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_init_a, N_init_A)
# initiate the variables
pop_new <- c(N_init_a, N_init_A)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.35,0,0,max_gen)
#Original
simulate_one_gen <- function(N_a, N_A, decay_rate, sel_coeff, mut_rate) {
# draw offspring according to Poisson distribution
offsp_a <- rpois(1, N_a * (1-decay_rate))
offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
# draw new mutants according to Poisson distribution
mut_a_to_A <- rpois(1, offsp_a * mut_rate)
# determine new population sizes of wild type and mutant
N_a_new <- max(offsp_a - mut_a_to_A, 0)
N_A_new <-  offsp_A + mut_a_to_A
return(c(N_a_new, N_A_new))
}
# Test the function
print(simulate_one_gen(100,0,0.1,0.2,0.0))
#Original
simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_init_a, N_init_A)
# initiate the variables
pop_new <- c(N_init_a, N_init_A)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data, without mut_rate & sel_coeff and a higher decay_rate
output <- simulate_pop(1000,0,0.1,0.2,0.001,max_gen)
# show the last few lines of the data table
print(output)
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_init_a, N_init_A)
# initiate the variables
pop_new <- c(N_init_a, N_init_A)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.35,0,0,max_gen)
# show the last few lines of the data table
print(output)
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
#Original
# set some parameters to fixed values
init_a <- 100
init_A <- 0
m_rate <- 0.001
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 100
# set parameters to vary
s_values <- c(0.2,0.3,0.4)
r_values <- c(0.05,0.1,0.15)
# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
# loop over selection coefficients
for(sval in s_values){
# different way of running many simulations: make replicates using "repeat" function with a counter i
# reset counter
i<-1
repeat {
# increase counter by one
i<-i+1
# run the simulation once
one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
# determine total population sizes
total_size <- one_run[,1]+one_run[,2]
# determine minimum population size
min_size <- min(total_size)
# determine (first) generation at which this population size occurred
min_gen <- as.numeric(which(total_size==min_size)[1])
# enter the data into the table
data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
# stop the repeated computation after no_replicates times
if(i>no_replicates) break
}
}
}
# define column names of data table
colnames(data_table) <- c("r","s","min_gen","no_min")
# show the first lines of the output
print(head(data_table))
# set some parameters to fixed values, m_rate is 0
init_a <- 100
init_A <- 0
m_rate <- 0
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 750
# set parameters to vary, r_values (decay) is fixed
s_values <- c(0.2,0.3,0.4)
r_values <- 0.35
# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
# loop over selection coefficients
for(sval in s_values){
# different way of running many simulations: make replicates using "repeat" function with a counter i
# reset counter
i<-1
repeat {
# increase counter by one
i<-i+1
# run the simulation once
one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
# determine total population sizes
total_size <- one_run[,1]+one_run[,2]
# determine minimum population size
min_size <- min(total_size)
# determine (first) generation at which this population size occurred
min_gen <- as.numeric(which(total_size==0))
# enter the data into the table
data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
# stop the repeated computation after no_replicates times
if(i>no_replicates) break
}
}
}
# define column names of data table
colnames(data_table) <- c("r","s","min_gen","no_min")
# show the first lines of the output
print(head(data_table))
#mean of generations after which the WT population goes extinct
mean.extWT <- mean(min_gen)
print(mean.extWT)
t_pause = 10#t_switch
t_event = 2
t_switch = t_pause
ph = 1
for (i in 1:t_max+1){
if(ph %%2 == 0){
decay_rate = 0.3
}else{
decay_rate = 0
}
#simulate one gen
if (i >= t_switch) {
if(ph %% 2 == 0) {
t_switch = t_switch + t_event
ph = ph + 1
}else{
t_switch = t_switch + t_pause
ph = ph + 1
}
}
}
decay_rate = c(0.35, 1.1) #decay rate in presence and absence of event --> strength of event
freq_event = 10 #every 10 generations an event happens
dur_event = 2 #event has a duration of 2 generations
t_max = 100
gen = 0
start_event = list()
while (gen < t_max){
start_event <- append(start_event, gen)
gen = gen + dur_event + freq_event
}
#print(start_event)
#start_event[1]
#start_event[2]
#start_event[3]
#start_event[4]
#start_event[5]
#start_event <- c(start_event,start_event+1,start_event+2)
simulate_one_gen_2 <- function(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen) {
if(gen %in% start_event) {
decay_rate = 0.35
growth_rate = 0
}
else{
decay_rate = 0
growth_rate = 1.1
}
offsp_a <- rpois(1, N_a * (1-decay_rate))
offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
# draw new mutants according to Poisson distribution
mut_a_to_A <- rpois(1, offsp_a * mut_rate)
# determine new population sizes of wild type and mutant
N_a_new <- max(offsp_a - mut_a_to_A, 0)
N_A_new <-  offsp_A + mut_a_to_A
return(c(N_a_new, N_A_new))
}
print(simulate_one_gen_2(100, 0, 0, 1.2, 0, 0, 3))
#for (i in 1:t_max+1) {
# new_pop <- simulate_one_gen_2(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen)
#vector_pop <- rbind(vector_pop, new_pop)
#if(new)
t_pause = 10#t_switch
t_event = 2
t_switch = t_pause
ph = 1
for (i in 1:t_max+1){
if(ph %%2 == 0){
decay_rate = 0.3
}else{
decay_rate = 0
}
#simulate one gen
if (i >= t_switch) {
if(ph %% 2 == 0) {
t_switch = t_switch + t_event
ph = ph + 1
}else{
t_switch = t_switch + t_pause
ph = ph + 1
}
}
}
simulate_pop <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
# Create the vector in which to save the results
pop_vector <- c(N_init_a, N_init_A)
# initiate the variables
pop_new <- c(N_init_a, N_init_A)
# run the simulation until generation t_max
for (i in 1:t_max+1) {
# redefine the current population one generation later
pop_new <- simulate_one_gen(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
# add the new population sizes to the output vector
pop_vector <- rbind(pop_vector,pop_new)
# condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
}
# define the row and column names of the output vector
rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
colnames(pop_vector) <- c("a","A")
# return the result
return(pop_vector)
}
# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data
output <- simulate_pop(1000,0,0.35,0,0,max_gen)
# show the last few lines of the data table
print(output)
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
decay_rate = c(0.35, 1.1) #decay rate in presence and absence of event --> strength of event
freq_event = 10 #every 10 generations an event happens
dur_event = 2 #event has a duration of 2 generations
t_max = 100
gen = 0
start_event = list()
while (gen < t_max){
start_event <- append(start_event, gen)
gen = gen + dur_event + freq_event
}
#print(start_event)
#start_event[1]
#start_event[2]
#start_event[3]
#start_event[4]
#start_event[5]
#start_event <- c(start_event,start_event+1,start_event+2)
simulate_one_gen_2 <- function(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen) {
if(gen %in% start_event) {
decay_rate = 0.35
growth_rate = 0
}
else{
decay_rate = 0
growth_rate = 1.1
}
offsp_a <- rpois(1, N_a * (1-decay_rate))
offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
# draw new mutants according to Poisson distribution
mut_a_to_A <- rpois(1, offsp_a * mut_rate)
# determine new population sizes of wild type and mutant
N_a_new <- max(offsp_a - mut_a_to_A, 0)
N_A_new <-  offsp_A + mut_a_to_A
return(c(N_a_new, N_A_new))
}
print(simulate_one_gen_2(100, 0, 0, 1.2, 0, 0, 3))
#for (i in 1:t_max+1) {
# new_pop <- simulate_one_gen_2(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate, gen)
#vector_pop <- rbind(vector_pop, new_pop)
#if(new)
