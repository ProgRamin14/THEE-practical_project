---
title: "THEE Project - Appendix"
output: html_notebook
---
## Making your results reproducible

When you generate “random numbers” in R, you are actually generating pseudorandom numbers. These numbers are generated with an algorithm that requires a seed to initialize. This means that if you know the seed and the generator, you can reproduce the output.

```{r}
# Draw 5 (pseudo)random numbers from a normal distribution
rnorm(5)
# Draw again 5 (pseudo)random numbers from a normal distribution
rnorm(5)
```

Expectedly, the numbers are different. How can we reproduce the exact output?

```{r}
#initialize the seed of the pseudo random generator
set.seed(1)
# Draw 5 (pseudo)random numbers from a normal distribution
rnorm(5)
#initialize the seed of the pseudo random generator
set.seed(1)
# Draw again 5 (pseudo)random numbers from a normal distribution
rnorm(5)
```


## Test-Area
This are just bits of code, that were used for the THEE project, to test things out. Nothing really worked as intended. It is here for the sake of hoarding and out of fear of deleting important bits.

```{r}
# Parameters
decay_rate = c(0.35, 1.1) # decay rate in presence and absence of event
freq_event = 10 # every 10 generations an event happens
dur_event = 2 # event has a duration of 2 generations
t_max = 100
gen = 0

# Create a list to store the results of each simulation
simulation_results <- list()

# Function to simulate one generation
simulate_one_gen_2 <- function(N_a, N_A, decay_rate, growth_rate, sel_coeff, mut_rate) {
  offsp_a <- rpois(1, N_a * (1 - decay_rate))
  offsp_A <- rpois(1, N_A * (1 - decay_rate + sel_coeff))
  
  # Draw new mutants according to Poisson distribution
  mut_a_to_A <- rpois(1, offsp_a * mut_rate)
  
  # Determine new population sizes of wild type and mutant
  N_a_new <- max(offsp_a - mut_a_to_A, 0)
  N_A_new <- offsp_A + mut_a_to_A
  
  return(c(N_a_new, N_A_new))
}

# Initialize populations
N_a <- 100
N_A <- 0
sel_coeff <- 0
mut_rate <- 0

# Main simulation loop
for (i in 1:10) { # Run the simulation 10 times
  gen <- 0
  populations <- matrix(0, nrow = t_max, ncol = 2)
  populations[1, ] <- c(N_a, N_A)
  
  while (gen < t_max) {
    # Check if the current generation is within an event
    if (gen %% freq_event == 0 && (gen / freq_event) %% (dur_event + 1) < dur_event) {
      current_decay_rate <- decay_rate[1] # Decay rate during event
    } else {
      current_decay_rate <- decay_rate[2] # Decay rate without event
    }
    
    # Simulate population for the current generation
    populations[gen + 1, ] <- simulate_one_gen_2(populations[gen + 1, 1], populations[gen + 1, 2], current_decay_rate, 1.2, sel_coeff, mut_rate)
    
    # Increment generation
    gen <- gen + 1
  }
  
  # Store the result of this simulation
  simulation_results[[i]] <- populations
}

# Example of printing results from the first simulation
print(simulation_results[[1]])

```
```{r}
simulate_pop_2 <- function(N_init_a, N_init_A, decay_rate, sel_coeff, mut_rate, t_max) {
  # Create the vector in which to save the results
  pop_vector <- c(N_init_a, N_init_A)
  # initiate the variables
  pop_new <- c(N_init_a, N_init_A)
  
  # run the simulation until generation t_max
  for (i in 1:t_max+1) {
    # redefine the current population one generation later
    pop_new <- simulate_one_gen_2(pop_new[1],pop_new[2], decay_rate, sel_coeff, mut_rate)
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
    # condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
    if (pop_new[1]+pop_new[2]>=1.5*(N_init_a+ N_init_A) | pop_new[1]+pop_new[2]==0) break
  }
  
  # define the row and column names of the output vector
  rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
  colnames(pop_vector) <- c("a","A")
  # return the result
  return(pop_vector)	
}


# Test the function and plot the result
# set t_max to a value to be used througout
max_gen <- 1000
# create your simulation data, without mut_rate & sel_coeff and a higher decay_rate
output <- simulate_pop_2(1000,0,0.35,0.2,0,max_gen)
# show the last few lines of the data table
print(output)
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range 
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Population size")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
```
```{r} 
# set some parameters to fixed values
init_a <- 100
init_A <- 0
m_rate <- 0
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 100

# set parameters to vary
s_values <- c(0.2,0.3,0.4)
r_values <- c(0.35, 1.1)

# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
  # loop over selection coefficients
  for(sval in s_values){
    # different way of running many simulations: make replicates using "repeat" function with a counter i
    # reset counter
    i<-1
    repeat {
      # increase counter by one
      i<-i+1
      # run the simulation once
      one_run <- simulate_pop_2(init_a,init_A,rval,sval,m_rate,max_gen)
      # determine total population sizes
      total_size <- one_run[,1]+one_run[,2]
      # determine minimum population size
      min_size <- min(total_size)
      # determine (first) generation at which this population size occurred
      min_gen <- as.numeric(which(total_size==min_size)[1])
      # enter the data into the table
      data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
      # stop the repeated computation after no_replicates times
      if(i>no_replicates) break
    }
  }
}
# define column names of data table
colnames(data_table) <- c("r","s","min_gen","no_min")
# show the first lines of the output
print(head(data_table))
```


